import datetime
import hashlib
import json
import os
import pandas
from dotenv import load_dotenv, find_dotenv
from json_vul_data.app.vulns_structure import VulnerabilityStructure

load_dotenv(find_dotenv())


def create_vulnerability_objects(file_path: str):
    """
    Function to read a CSV for Vulnerability Management
    :param file_path: path to CSV file
    :return: list of vulnerability objects
    """
    vulnerability_list = []
    try:
        df = pandas.read_csv(file_path)
        for index, row in df.iterrows():
            row_data_dict = row.to_dict()
            vulnerability_obj = VulnerabilityStructure(
                row_data_dict['Initiative'],
                row_data_dict['AppSec Consultant'],
                row_data_dict['Jira Issue Key'],
                row_data_dict['App Code'],
                row_data_dict['App Name'],
                datetime.date.fromisoformat(row_data_dict['ReportDate']),
                row_data_dict['Vulnerability Name'],
                row_data_dict['Technical Rating'],
                row_data_dict['CVSS Vector'],
                row_data_dict['Impact Description'],
                row_data_dict['Comment'],
                row_data_dict['Vendor']
            )
            vulnerability_list.append(vulnerability_obj)
    except Exception as e:
        print(e)

    return vulnerability_list


def create_json_from_object(vulnerability_obj: VulnerabilityStructure):
    """
    Function to output a JSON for Vulnerabilities with md5 hash for unique identifier
    :param vulnerability_obj:
    :return: dictionary for json output
    """
    identifier = vulnerability_obj.app_code + "-" + vulnerability_obj.report_date.isoformat() + "-" + \
                 vulnerability_obj.jira_issue_key + "-" + vulnerability_obj.vul_name
    identifier_hash = hashlib.md5(identifier.encode('utf-8')).hexdigest()
    output_dict = {
        "skip_autoclose": False,
        "assets": [
            {
                "file": vulnerability_obj.app_name,
                "external_id": vulnerability_obj.app_code,
                "tags": [vulnerability_obj.app_code],
                "owner": None,
                "priority": None,
                "application": vulnerability_obj.app_code + "_" + vulnerability_obj.app_name,
                "vulns": [
                    {
                        "scanner_identifier": identifier_hash,
                        "scanner_type": vulnerability_obj.vendor,
                        "scanner_score": vulnerability_obj.calculate_technical_rating(),
                        "created_at": vulnerability_obj.report_date.isoformat(),
                        "last_seen_at": vulnerability_obj.report_date.isoformat(),
                        "status": "open"
                    }
                ]
            }
        ],
        "vuln_defs": [
            {
                "scanner_identifier": identifier_hash,
                "scanner_type": vulnerability_obj.vendor,
                "name": vulnerability_obj.app_name,
                "description": "CVSS Vector: " + vulnerability_obj.cvss_vector + " | "
                               + "Comment: " + vulnerability_obj.comment + " | " +
                               "Impact Desc: " + vulnerability_obj.impact_description,
                "solution": None
            }
        ]
    }

    return output_dict


def main(csv_path: str, json_path: str):
    """
    Driver function to run program
    """
    json_dict_list = []
    object_list = create_vulnerability_objects(csv_path)
    for obj in object_list:
        json_out = create_json_from_object(obj)
        json_dict_list.append(json_out)

    with open(json_path, 'w') as json_file:
        json.dump(json_dict_list, json_file)


if __name__ == "__main__":
    CSV_FILE_PATH = os.getenv("CSV_FILE_PATH")
    JSON_FILE_PATH = os.getenv("JSON_FILE_PATH")
    main(CSV_FILE_PATH, JSON_FILE_PATH)
